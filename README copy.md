# MPC Algorithm for Differential Autonomous Vehicle

This project implements a Model Predictive Control (MPC) algorithm for controlling a differential drive autonomous vehicle. The control framework leverages Particle Swarm Optimization (PSO) to optimize robot velocity, ensuring the robot follows a given reference trajectory. The project integrates trajectory generation, sensor feedback, and motor control through the Robot Operating System (ROS), and it is capable of being simulated in Gazebo or deployed on real hardware.

## Project Structure

The project is organized into four main components:

### 1. **MPC Algorithm (`MPC.cpp`)**
This file contains the core of the Model Predictive Control (MPC) algorithm. The MPC uses **Particle Swarm Optimization (PSO)** to calculate the optimal velocity inputs for the robot, minimizing the error between the current state and the reference trajectory.

**Key Features**:
- Predicts the future states of the robot based on its kinematic model.
- Optimizes control inputs (velocity and steering) to minimize the trajectory tracking error.
- Considers velocity and acceleration constraints to ensure smooth, safe motion.

### 2. **Trajectory Generation (`ref.cpp`)**
The `ref.cpp` file is responsible for generating predefined trajectories that the robot needs to follow. The current implementation includes:
- **Circular Trajectory**: A circular path for the robot to follow.
- **Straight Line Trajectory**: A simple linear path.

These reference trajectories are passed to the MPC for trajectory tracking.

### 3. **Main Controller (`main.cpp`)**
This file serves as the main entry point for the entire system. It manages the interaction between different modules and handles communication via ROS. 

**Responsibilities**:
- Initializes ROS nodes and sets up communication between the control algorithm and the robot.
- Calls the MPC algorithm to compute desired control inputs.
- Publishes control commands to either the robot’s motors (for hardware) or Gazebo (for simulation).

### 4. **Arduino Code (`robot_controller.ino`)**
This Arduino sketch is responsible for acquiring sensor data and controlling the motors. It reads sensor values such as encoder data and gyroscope readings to estimate the robot’s odometry (position and orientation). Additionally, it implements a PID control loop for precise velocity control of the motors.

**Key Functions**:
- Estimates the robot’s state using encoders and gyroscope data.
- Implements a PID controller to regulate motor velocity.
- Communicates with the MPC controller (via ROS) to receive desired velocity commands.

## Simulation and Hardware Implementation

### Gazebo Simulation
The project includes a Gazebo simulation environment where you can test and validate the control algorithm. The simulated robot is a differential drive robot, and the MPC algorithm is used to control its motion.

**Demonstration Video**:
Watch a video of the Gazebo simulation [here](https://drive.google.com/file/d/1G1k8OX83KltEySx1zqu4JQXIHo-Ti51P/view?usp=sharing).

The Gazebo model used in this project is based on the following package: [Differential Drive Robot](https://github.com/sanuann/DifferentialDriveRobot).

### Hardware Setup
For real-world applications, the MPC controller can be deployed on a Raspberry Pi (or another embedded system), which communicates with the Arduino microcontroller via ROS. The Arduino controls the motors and reads sensor data, allowing the MPC to close the loop between sensing and actuation.

The folder `ino_cpp` contains a ROS package. The executable `main` generated by this package should be executed alongside the ROS master. The system can run in either simulation mode (Gazebo) or on physical hardware (with Arduino and sensors).

## How It Works

1. **Trajectory Generation**: The robot’s desired path (e.g., circular or linear) is generated.
2. **MPC Optimization**: The MPC algorithm calculates optimal control inputs to follow the trajectory while considering physical constraints.
3. **Motor Control**: The Arduino uses a PID controller to regulate motor velocity, ensuring the robot follows the desired path.
4. **Feedback Loop**: Sensors provide real-time data to update the MPC and improve future predictions.

## Installation and Execution

To run the project, ensure that you have ROS installed along with the necessary dependencies (such as Gazebo for simulation). The Arduino code should be uploaded to a microcontroller for hardware deployment.

# 1. Install ROS:
Follow the instructions at https://wiki.ros.org/ROS/Installation to install the appropriate ROS distribution for your system.

# 2. Clone the Repository:
`git clone https://github.com/your-repo/MPC-algo-for-differential-autonomous-vehicule`

# 3. Build the ROS Package:
`cd ino_cpp`
`catkin_make`

# 4. Upload Arduino Code:
Open the Arduino IDE and upload the robot_controller.ino file to your Arduino board.

# 5. Run the Gazebo Simulation:
roslaunch differential_drive_robot gazebo.launch

# 6. Run the Main Node:
`rosrun ino_cpp main`

# Dependencies
### ROS (Robot Operating System)
### Gazebo
### Arduino IDE
